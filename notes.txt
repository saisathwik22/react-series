"# react-series" 
#1 
intro to what is react?

** use REACT.dev documentation **

__________________________________________________________________________________________________________________________

#2 - create react and vite folders

react is a library
react-dom, react-native are attachements provided with react library
for website working --> use react with react-dom
for mobile apps --> use react with react-native
react --> using with a framework --> exmaple: next.js
react --> using without a framework --> use bundlers like vite or parcel

npm [node package manager] --> installer for node.js
but many a times, user may not be ok with installing the packages, instead they prefer direct execution, so they use

npx [node package executer]  

create-react-app --> utility/software used to create projects
npx create-react-app filename(noCaps) ---> installation method, but takes time
create-react-app --> famous, but bulky with big bundle size.

scripts in react:
start --> to run projects in dev environment [npm run start]
build --> browser only understands html,js --> so to manage react in production use build
test --> to run all test cases
eject --> eject your application from react.

when npm run build is hit --> build folder gets created --> whatever js that was written in react, got converted into this build, when code goes to production this build is served to the user, not the src folder

alternative to create-react-app utility
npm create vite@latest --> give project name --> select framework --> select variant(js/ts)
but in vite file there is no node_modules created.
so install node_modules using npm install command inside the vite project
__________________________________________________________________________________________________________________________

#3 - Understanding react flow and structure

whenever you create components in vite --> use jsx or tsx --> because vite is configured to read jsx/tsx

in jsx file, when you use return() there should be only one tag in return. make a div, and keep as many of tags as you want in that div, but externally only 1 tag allowed in return()
return (
      <p></p>
      <h></h>
)
above not allowed, instead write as below
return (
      <div>
            <p></p>
            <h></h>
      </div>
)
this is allowed

good practice --> function name and file/components name start with Caps
__________________________________________________________________________________________________________________________

#4 - Creating own react library and JSX

Standard way of writing react element.
reactElement = {
      type: "type of html element",
      props: {
            properties of element we want to add like href, target 
      }
      children: " "
}
now inject this reactElement into root container
method name can be anything, say customRender but it needs to be defined and written.
customRender("file need to be injected", "location where the file is to be injected")
__________________________________________________________________________________________________________________________

#5 - HOOKS !
hooks need to be imported in following way only: import { hookName } from 'react' because they are exported in the same way.
useState --> used to change the state, change doesnt mean value updation, change is propogated into your UI's dom.
--> useState() --> values can be --> number, string, array, boolean, function, object etc..

let [counter, setCounter] = useState(15);
setCounter --> takes in the new value that has to be put in counter variable
__________________________________________________________________________________________________________________________

#6 - Virtual DOM, Fibre and reconciliation..

ReactDOM.createRoot() --> createRoot creates DOM like structure behind the scenes.
when page reloads --> bts the browser removes the whole dom, then re-structures the whole dom again from scratch.
but, in virtualDOM --> only the values which have changed are removed and updated, instead of re-structuring whole dom.

React Fibre Architecture :
- well implemented algorithm 
- goal of react fibre is to increase its suitability for areas like animation, layout and gestures.
- incremental rendering: ability to split rendering work into chunks and spread it out over multiple frames.
- key features - ability pause, abort and reuse the work as updates come in, ability to assign priority to diff types of updates.

Reconciliation: 
- recursive algorithm that react uses to compare two trees to determine which parts need to be changed.
- these react trees arise from createRoot() method

Hydration concept --> adding functionality to elements like buttons, images, web layout by injecting javaScript into it.

Idea of React API 
--> think of updates, as they cause entire app to re-render.
--> this allows developer to reason declaratively, rather than worry about how state transition of an app happens efficiently.
--> re-rendering entire app on each change only works for most trivial apps.
--> in real world app, its costly in terms of performance.
--> react has optimizations which create appearance of whole app re-rendering while maintaining great performance.
--> the bulk of these optimizations are part of process called reconciliation.

** Reconciliation 
- algorithm behind what is popularly understood as virtualDOM. 
- when you render a react app, a tree of nodes that describes the app is generated and saved in memory.
- this tree is now flushed to rendering environment.

Example:
in case of browser app --> its translated to set of DOM operations. when app is updated (usually via setState) --> a new tree is generated.
this new tree is compared with previous tree to compute which operations are needed to update the rendered app.

* Differentiation of lists is performed using keys.
* Keys should be stable, predictable and unique

Key Points:
* in a UI, its not necessary for every update to be applied instantly, infact doing so can cause frames to drop and degrading user experience.
* Diff types of updates have diff priorities
* push-based approach requires app to decide how to schedule work.
* pull-based approach follows framework to be smart and make those decisions for you.

Fiber: 
lower level abstraction than application developers typically think about.
- pause work and come back to it later.
- assign priority to different types of work.
- reuse previously completed work
- abort work if its no longer needed.
__________________________________________________________________________________________________________________________

#7 - Tailwind and props in reactJS

03-Tailwindprops file

tailwind package :
[inside your vite project file]
npm install -D tailwindcss postcss autoprefixer
npx tailwindcss init -p

then inside tailwind config file, add this content
"./index.html", "./src/**/*.{js,ts,jsx,tsx}"

include these decorators in css file
@tailwind base, components, utilities

props: make components re-usable.
example: you have a card component code snippet in card.jsx
import this card into app.jsx and use as <card />
now you can use this card multiple times.
if you are using this card multiple times in app.jsx , and you need different data inside the card each time you use it, use "props"
ex: if card contains name/title, you need two cards with different name/title, use "props"
config name/title in card.jsx by passing {name} into card function 
use <card name='sathwik' /> in card.jsx
__________________________________________________________________________________________________________________________

#8 - interview specific in reactJS
starting from 15, when you click addValue, how will number increase.
ans: number increases by 1 only.
const addValue = () => {
  //counter = counter + 1
  setCounter(counter + 1)
  setCounter(counter + 1)
  setCounter(counter + 1)
  setCounter(counter + 1)
};

when you use
const addValue = () => {
  //counter = counter + 1
  setCounter(prevCounter => prevCounter + 1)
  setCounter(prevCounter => prevCounter + 1)
  setCounter(prevCounter => prevCounter + 1)
  setCounter(prevCounter => prevCounter + 1)
};
increments previous number by 1 in each call.
ans: number increases by 4. 
__________________________________________________________________________________________________________________________

#9 - building react project - bgChanger

list of colors given, click on it to change the color
create vite project file, install npm, tailwind package

set default color:
const [color, setColor] = useState("aliceblue");

sample color button:
<button
  onClick={() => setColor("blue")}
  className='outline-none px-4 py-1 rounded-full text-white shadow-lg'
  style={{ backgroundColor: "blue" }}
> Blue </button>
__________________________________________________________________________________________________________________________

#10 - useEffect, useRef and useCallback with project

Random Password-type string including numbers, special characters, with seek bar deciding length of password, copy button which copies the string.

useCallback : react hook that lets you cache a function definition between re-renders.
useCallback(function, dependenies)

useEffect: lets you synchronize a component with an external system
useEffect(setup, dependenies?)
dependenies array - array which contains methods/functions which when hit, impacts the useEffect

Synchronizing with effects:
effects lets you run some code after rendering so that you can synchronize your component with system outside of react

useRef() : when user needs to take reference of anything, useRef() is used.
______________________________________________________________________________________________________________________________________________________

#11 - Custom Hooks in react | currency project

whenever creating hooks, start with use --> standard approach

we are creating a hook called "useCurrencyInfo".
many hooks have optional argument but our hook has to be provided with currency info.
so pass on the argument "currency" inside the above hook.
This hook returns a data. We want to call API in this hook.
use "useEffect" because when this method is hit it automatically fetches the API, no need of fetching the API manually.
this "useEffect" needs callback function and a dependency array.
mention currency url in fetch call, convert response to json. Extract key value from currency info.

export the hook default method.

key is important for loops in react.

useId hook -> to generate unique IDs

Do not call useId to generate keys in a list, Keys should be generated from your data.